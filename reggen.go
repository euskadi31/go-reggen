// Package reggen generates text based on regex definitions
package reggen

import (
	"fmt"
	"math"
	"math/rand"
	"os"
	"regexp/syntax"
	"time"
)

const runeRangeEnd = 0x10ffff
const printableChars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n\r"

var printableCharsNoNL = printableChars[:len(printableChars)-2]

type state struct {
	limit int
}

// Generator struct.
type Generator struct {
	re   *syntax.Regexp
	rand *rand.Rand
}

// NewGenerator create a new generator.
func NewGenerator(regex string) (*Generator, error) {
	re, err := syntax.Parse(regex, syntax.Perl)
	if err != nil {
		return nil, fmt.Errorf("failed to parse regex: %w", err)
	}

	g := &Generator{
		re: re,
	}

	g.Seed(time.Now().UnixNano())

	return g, nil
}

//nolint:gocyclo
func (g *Generator) generate(s *state, re *syntax.Regexp) string {
	op := re.Op

	switch op {
	case syntax.OpNoMatch:
	case syntax.OpEmptyMatch:
		return ""
	case syntax.OpLiteral:
		res := ""

		for _, r := range re.Rune {
			res += string(r)
		}

		return res
	case syntax.OpCharClass:
		// number of possible chars
		sum := 0

		for i := 0; i < len(re.Rune); i += 2 {
			sum += int(re.Rune[i+1]-re.Rune[i]) + 1
			if re.Rune[i+1] == runeRangeEnd {
				sum = -1

				break
			}
		}

		// pick random char in range (inverse match group)
		if sum == -1 {
			possibleChars := []uint8{}

			for j := 0; j < len(printableChars); j++ {
				c := printableChars[j]

				// Check c in range
				for i := 0; i < len(re.Rune); i += 2 {
					if rune(c) >= re.Rune[i] && rune(c) <= re.Rune[i+1] {
						possibleChars = append(possibleChars, c)

						break
					}
				}
			}

			if len(possibleChars) > 0 {
				c := possibleChars[g.rand.Intn(len(possibleChars))]

				return string([]byte{c})
			}
		}

		r := g.rand.Intn(sum)

		var ru rune

		sum = 0

		for i := 0; i < len(re.Rune); i += 2 {
			gap := int(re.Rune[i+1]-re.Rune[i]) + 1

			if sum+gap > r {
				ru = re.Rune[i] + rune(r-sum)

				break
			}

			sum += gap
		}

		return string(ru)
	case syntax.OpAnyCharNotNL, syntax.OpAnyChar:
		chars := printableChars
		if op == syntax.OpAnyCharNotNL {
			chars = printableCharsNoNL
		}

		c := chars[g.rand.Intn(len(chars))]

		return string([]byte{c})
	case syntax.OpBeginLine:
	case syntax.OpEndLine:
	case syntax.OpBeginText:
	case syntax.OpEndText:
	case syntax.OpWordBoundary:
	case syntax.OpNoWordBoundary:
	case syntax.OpCapture:
		return g.generate(s, re.Sub0[0])
	case syntax.OpStar:
		// Repeat zero or more times
		res := ""
		count := g.rand.Intn(s.limit + 1)

		for i := 0; i < count; i++ {
			for _, r := range re.Sub {
				res += g.generate(s, r)
			}
		}

		return res
	case syntax.OpPlus:
		// Repeat one or more times
		res := ""
		count := g.rand.Intn(s.limit) + 1

		for i := 0; i < count; i++ {
			for _, r := range re.Sub {
				res += g.generate(s, r)
			}
		}

		return res
	case syntax.OpQuest:
		// Zero or one instances
		res := ""
		count := g.rand.Intn(2)

		for i := 0; i < count; i++ {
			for _, r := range re.Sub {
				res += g.generate(s, r)
			}
		}

		return res
	case syntax.OpRepeat:
		// Repeat one or more times
		res := ""
		count := 0
		re.Max = int(math.Min(float64(re.Max), float64(s.limit)))

		if re.Max > re.Min {
			count = g.rand.Intn(re.Max - re.Min + 1)
		}

		for i := 0; i < re.Min || i < (re.Min+count); i++ {
			for _, r := range re.Sub {
				res += g.generate(s, r)
			}
		}

		return res
	case syntax.OpConcat:
		// Concatenate sub-regexes
		res := ""
		for _, r := range re.Sub {
			res += g.generate(s, r)
		}

		return res
	case syntax.OpAlternate:
		i := g.rand.Intn(len(re.Sub))

		return g.generate(s, re.Sub[i])
	default:
		fmt.Fprintln(os.Stderr, "[reg-gen] Unhandled op: ", op)
	}

	return ""
}

// Generate returns string generated by regexp
// limit is the maximum number of times star, range or plus should repeat
// i.e. [0-9]+ will generate at most 10 characters if this is set to 10.
func (g *Generator) Generate(limit int) string {
	return g.generate(&state{limit: limit}, g.re)
}

// Seed define new seed.
func (g *Generator) Seed(seed int64) {
	//nolint:gosec
	g.rand = rand.New(rand.NewSource(seed))
}
